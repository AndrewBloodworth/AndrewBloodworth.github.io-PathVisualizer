{"version":3,"sources":["algorithms/dijkstras.js","components/nav/Nav.js","components/grid/gridSlice.js","components/grid/Gridrow.js","components/grid/Grid.js","app/App.js","app/store.js","index.js"],"names":["lowestCostNode","costs","processed","Object","keys","reduce","lowest","node","includes","graph","walls","boxes","dijkstra","a","assign","end","Infinity","startNode","parents","wall","child","myPromise","Promise","resolve","reject","interval","setInterval","cost","children","n","newCost","el","document","getElementById","className","endNode","clearInterval","push","optimalPath","parent","reverse","results","distance","path","Nav","handleClick","box","result","shift","pop","i","length","onClick","splice","indexOf","gridSlice","createSlice","name","initialState","grid","rows","cols","reducers","setGrid","state","action","payload","actions","selectGrid","Gridrow","mouseDown","setMouseDown","setNode","currentRow","useSelector","handleMouseDown","e","preventDefault","target","previous","currentlyMoving","type","addRemoveWalls","handleMouseUp","id","handleMouseLeave","handleMouseEnter","Array","map","col","cName","start","index","row","Number","slice","right","left","up","down","buildGraph","onMouseEnter","onMouseDown","onMouseUp","onMouseLeave","Grid","dispatch","useDispatch","useState","bool","useEffect","Math","floor","window","innerHeight","innerWidth","vertMiddle","horzFirstThird","horzLastThird","App","store","configureStore","reducer","gridReducer","ReactDOM","render"],"mappings":"oMAAMA,EAAiB,SAACC,EAAOC,GAC3B,OAAOC,OAAOC,KAAKH,GAAOI,QAAO,SAACC,EAAQC,GAItC,OAHe,OAAXD,GAAmBL,EAAMM,GAAQN,EAAMK,MAClCJ,EAAUM,SAASD,KAAOD,EAASC,IAErCD,IACR,OAGMG,EAAQ,GACRC,EAAQ,GAERC,EAAQ,GAcRC,EAAQ,uCAAG,kDAAAC,EAAA,sDACdZ,EAAQE,OAAOW,OAAO,CAACC,IAAKC,KAAWP,EAAMA,EAAMQ,YACnDC,EAAU,CAACH,IAAK,MAChBb,EAAY,GAHE,cAIHQ,GAJG,IAIpB,2BAASS,EAAT,QAA4BlB,EAAMkB,WAAcV,EAAMU,GAJlC,8BAKpB,IAASC,KAASX,EAAMA,EAAMQ,WAAYC,EAAQE,GAASX,EAAMA,EAAMQ,WALnD,OAOhBV,EAAOP,EAAeC,EAAOC,GAE3BmB,EAAY,IAAIC,SAAQ,SAACC,EAASC,GACpC,IAAIC,EAAWC,aAAY,WACvB,IAAIC,EAAO1B,EAAMM,GACbqB,EAAWnB,EAAMF,GACrB,IAAK,IAAIsB,KAAKD,EACV,IAAKlB,EAAMF,SAASqB,GAAI,CACpB,IAAIC,EAAUH,EAAOC,EAASC,GACzB5B,EAAM4B,KACP5B,EAAM4B,GAAKC,EACXZ,EAAQW,GAAKtB,GAEbN,EAAM4B,GAAKC,IACX7B,EAAM4B,GAAKC,EACXZ,EAAQW,GAAKtB,GAIzB,IAAMwB,EAAKC,SAASC,eAAe1B,GAC/BwB,GAAuB,eAAjBA,EAAGG,WAA+C,aAAjBH,EAAGG,YAA6BxB,EAAMF,SAASD,KAAOwB,EAAGG,UAAY,WAC5G3B,IAASE,EAAM0B,UACfC,cAAcX,GACdF,KAEJrB,EAAUmC,KAAK9B,IACfA,EAAOP,EAAeC,EAAOC,KAClBkC,cAAcX,KAC1B,OAnCa,UAsCdJ,EAtCc,QA2CpB,IAHIiB,EAAc,CAAC7B,EAAM0B,SACrBI,EAASrB,EAAQT,EAAM0B,SAEpBI,GACHD,EAAYD,KAAKE,GACjBA,EAASrB,EAAQqB,GA7CD,OAgDpBD,EAAYE,UAENC,EAAU,CAChBC,SAAUzC,EAAMQ,EAAM0B,SACtBQ,KAAML,IAEM,EAtDQ,kBAuDbG,GAvDa,4CAAH,qD,OCvBRG,EAAM,WACf,IAAMC,EAAW,uCAAG,0CAAAhC,EAAA,oEACAF,GADA,IAChB,IAAI,EAAJ,qBAASmC,EAAc,QAEE,aADff,EAAKC,SAASC,eAAea,IAC5BZ,WAA4C,SAAjBH,EAAGG,YAAsBH,EAAGG,UAAY,aAH9D,8CAKGtB,IALH,QAKZmC,EALY,QAMTJ,KAAKK,QACZD,EAAOJ,KAAKM,MACRC,EAAI,EAAGC,EAASJ,EAAOJ,KAAKQ,OAC1B1B,EAAWC,aAAY,WACzBM,SAASC,eAAec,EAAOJ,KAAKO,IAAIhB,UAAY,SACpDgB,IACUC,GAAQf,cAAcX,KAClC,GAbc,2CAAH,qDAsBjB,OACI,sBAAKS,UAAU,MAAf,UACI,qBAAKA,UAAU,YAAf,SACI,mDAEJ,qBAAKA,UAAU,cAAf,SACI,wBAAQkB,QAASP,EAAjB,6BAEJ,qBAAKX,UAAU,eAAf,SACI,wBAAQkB,QAhBA,WAAO,IAAD,gBACNzC,GADM,IACtB,IAAI,EAAJ,qBAAuB,CAAC,IAAfmC,EAAc,QACbf,EAAKC,SAASC,eAAea,GACd,YAAjBf,EAAGG,WAA4C,SAAjBH,EAAGG,WAAyC,SAAjBH,EAAGG,YAAsBH,EAAGG,UAAY,aACjGxB,EAAMF,SAASsC,IAAMpC,EAAM2C,OAAO3C,EAAM4C,QAAQR,GAAK,IAJvC,gCAgBd,+B,+BCjCVS,EAAYC,YAAY,CAC1BC,KAAM,OACNC,aAAc,CACVC,KAAM,CACFC,KAAM,KACNC,KAAM,OAGdC,SAAU,CACNC,QADM,SACEC,EAAMC,GACV,MAAO,CACHN,KAAMM,EAAOC,aAQdH,EAAYR,EAAUY,QAAtBJ,QAIAR,IAAf,QAIaa,EAAa,SAACJ,GAAD,OAAWA,EAAML,MCxB9BU,EAAU,SAAC,GAA4D,IAA1DC,EAAyD,EAAzDA,UAAWC,EAA8C,EAA9CA,aAAchE,EAAgC,EAAhCA,KAAMiE,EAA0B,EAA1BA,QAASC,EAAiB,EAAjBA,WACtDd,EAASe,YAAYN,GAArBT,KAEFgB,EAAkB,SAACC,GACrBA,EAAEC,iBAKED,EAAEE,OAAO5C,UAAU1B,SAAS,SAASgE,EAAQ,CAACO,SAAUH,EAAEE,OAAQE,iBAAiB,EAAMC,KAAML,EAAEE,OAAO5C,YAC5GqC,GAAa,GACbW,EAAeN,EAAEE,SAEfK,EAAgB,SAAC,GAAgB,IAAdL,EAAa,EAAbA,OAEI,eAArBA,EAAO5C,UAA4BzB,EAAMQ,UAAY6D,EAAOM,GAClC,aAArBN,EAAO5C,YAA0BzB,EAAM0B,QAAU2C,EAAOM,IAEjEZ,EAAQ,2BAAIjE,GAAL,IAAWyE,iBAAiB,KACnCT,GAAa,IAEXc,EAAmB,SAAC,GAAgB,IAAdP,EAAa,EAAbA,OAIpBpE,EAAMF,SAASsE,EAAOM,KAAO7E,EAAKyE,kBAAiBF,EAAO5C,UAAY,QACxD,eAAd3B,EAAK0E,MAAyBH,EAAOM,KAAO3E,EAAM0B,UAAS2C,EAAO5C,UAAY,YAChE,aAAd3B,EAAK0E,MAAuBH,EAAOM,KAAO3E,EAAMQ,YAAW6D,EAAO5C,UAAY,eAEhFoD,EAAmB,SAAC,GAAgB,IAAdR,EAAa,EAAbA,OAEpBvE,EAAKyE,iBAELF,EAAO5C,UAAY3B,EAAK0E,KAEQ,SAA5B1E,EAAKwE,SAAS7C,YAAsB3B,EAAKwE,SAAS7C,UAAY,aAElEsC,EAAQ,2BAAIjE,GAAL,IAAWwE,SAAUD,MACrBR,GAAWY,EAAeJ,IAEnCI,EAAiB,SAACJ,GACpB,OAAQA,EAAO5C,WACX,IAAK,YAEDxB,EAAM2B,KAAKyC,EAAOM,IAElBN,EAAO5C,UAAY,OACnB,MACJ,IAAK,OAEDxB,EAAM2C,OAAO3C,EAAM4C,QAAQwB,EAAOM,IAAI,GAEtCN,EAAO5C,UAAY,cAsB/B,OAfW,YAAIqD,MAAM5B,EAAKE,MAAMzD,QAAQoF,KAAI,SAAAC,GACpC,IAAIC,EAKJ,OAJ+CA,EAA9CjF,EAAMQ,YAAN,UAAuBwD,EAAvB,YAAqCgB,GAAiB,aACtDhF,EAAM0B,UAAN,UAAqBsC,EAArB,YAAmCgB,GAAiB,WACpD/E,EAAMF,SAAN,UAAkBiE,EAAlB,YAAgCgB,IAAkB,OAAiB,YHtDtD,SAACE,EAAMD,GAAW,IAAD,EACnCE,EAAQD,EAAMrC,QAAQ,KACtBuC,EAAMC,OAAOH,EAAMI,MAAM,EAAEH,IAC3BH,EAAMK,OAAOH,EAAMI,MAAMH,EAAM,EAAED,EAAMxC,SACvC6C,EAAQP,EAAI,EAAIhF,EAAMoD,KAAK,EAAI,KAAvB,UAAiCgC,EAAjC,YAAwCJ,EAAI,GACpDQ,EAAOR,EAAI,EAAI,EAAI,KAAZ,UAAsBI,EAAtB,YAA6BJ,EAAI,GACxCS,EAAKL,EAAI,EAAIpF,EAAMmD,KAAK,EAAI,KAAvB,UAAiCiC,EAAI,EAArC,YAA0CJ,GAC/CU,EAAON,EAAI,EAAI,EAAI,KAAZ,UAAsBA,EAAI,EAA1B,YAA+BJ,GAC5B,SAAVC,IAAkBjF,EAAMkF,IAAN,mBAAkBK,EAAQ,GAA1B,cAA8BC,EAAO,GAArC,cAAyCC,EAAK,GAA9C,cAAkDC,EAAO,GAAzD,IACtBxF,EAAM0B,KAAKsD,GG8CHS,CAAW,GAAD,OAAI3B,EAAJ,YAAkBgB,GAAMC,GAC3B,oBACKN,GAAE,UAAKX,EAAL,YAAmBgB,GACrBvD,UAAWwD,EACXW,aAAcf,EACdgB,YAAa3B,EACb4B,UAAWpB,EACXqB,aAAcnB,GANVI,OChEfgB,EAAO,WAChB,IAAQ9C,EAASe,YAAYN,GAArBT,KACF+C,EAAWC,cACjB,EAAkCC,oBAAS,GAA3C,mBAAOtC,EAAP,KAAkBC,EAAlB,KACA,EAAwBqC,mBAAS,CAAC9B,OAAQ,KAAM+B,MAAM,IAAtD,mBAAOtG,EAAP,KAAaiE,EAAb,KAEAsC,qBAAU,WACN,IAAIlD,EAAOmD,KAAKC,OAAOC,OAAOC,YAAc,IAAM,IAC9CrD,EAAOkD,KAAKC,MAAMC,OAAOE,WAAa,IAAI,EAC9C1G,EAAMmD,KAAOA,EACbnD,EAAMoD,KAAOA,EACb,IAAMuD,EAAaL,KAAKC,MAAMpD,EAAO,GAC/ByD,EAAiBN,KAAKC,MAAMnD,EAAO,GACnCyD,EAAgBzD,EAAOkD,KAAKC,MAAMnD,EAAO,GAC/CpD,EAAMQ,UAAN,UAAqBmG,EAArB,YAAmCC,GACnC5G,EAAM0B,QAAN,UAAmBiF,EAAnB,YAAiCE,GACjCZ,EAAS3C,EAAQ,CAACH,OAAKC,YACzB,CAAC6C,IAcH,OACI,qBAAKxE,UAAU,iBAAiBsE,aAdX,SAAC5B,GACtBJ,EAAQ,2BAAIjE,GAAL,IAAWyE,iBAAiB,EAAO6B,MAAM,KAChDtC,GAAa,IAYb,SACA,qBAAKrC,UAAU,OAAf,SACI,uBAAOA,UAAU,aAAjB,SACI,gCAZD,YAAIqD,MAAM5B,EAAKC,MAAMxD,QAAQoF,KAAI,SAAAK,GAAG,OAAI,oBAAcT,GAAE,cAASS,GAAzB,SAC3C,cAAC,EAAD,CACQpB,WAAYoB,EACZvB,UAAWA,EACXC,aAAcA,EACdhE,KAAMA,EACNiE,QAASA,GALHqB,IADsCA,eCzBnD0B,EAAM,WACf,OACI,uBAAMrF,UAAU,MAAhB,UACI,cAAC,EAAD,IACA,cAAC,EAAD,QCJCsF,EAASC,YAAe,CACjCC,QAAS,CACL/D,KAAMgE,KCCZC,IAASC,OACP,cAAC,IAAD,CAAUL,MAAOA,EAAjB,SACI,cAAC,EAAD,MAEJxF,SAASC,eAAe,W","file":"static/js/main.19d6cdee.chunk.js","sourcesContent":["const lowestCostNode = (costs, processed) => {\n    return Object.keys(costs).reduce((lowest, node) => {\n        if (lowest === null || costs[node] < costs[lowest]) {\n            if (!processed.includes(node)) lowest = node;\n        }\n        return lowest;\n    }, null);\n  };\n\nexport const graph = {}\nexport const walls = [];\nexport let completed = false;\nexport const boxes = []\n\nexport const buildGraph = (start,cName) => {\n    let index = start.indexOf('-');\n    let row = Number(start.slice(0,index))\n    let col = Number(start.slice(index+1,start.length))\n    let right = col+1 > graph.cols-1 ? null : `${row}-${col+1}`;\n    let left = col-1 < 0 ? null : `${row}-${col-1}`;\n    let up = row+1 > graph.rows-1 ? null : `${row+1}-${col}`;\n    let down = row-1 < 0 ? null : `${row-1}-${col}`;\n    if (cName !== 'wall') graph[start] = { [right]: 1, [left]: 1, [up]: 1, [down]: 1 };\n    boxes.push(start);\n}\n\nexport const dijkstra = async () => {\n    const costs = Object.assign({end: Infinity}, graph[graph.startNode]);\n    const parents = {end: null};\n    const processed = [];\n    for (let wall of walls) if (costs[wall]) delete graph[wall]\n    for (let child in graph[graph.startNode]) parents[child] = graph[graph.startNode];\n\n    let node = lowestCostNode(costs, processed);\n\n    const myPromise = new Promise((resolve, reject) => {\n        let interval = setInterval(() => {\n            let cost = costs[node];\n            let children = graph[node];\n            for (let n in children) {\n                if (!walls.includes(n)) {\n                    let newCost = cost + children[n];\n                    if (!costs[n]) {\n                        costs[n] = newCost;\n                        parents[n] = node;\n                    }\n                    if (costs[n] > newCost) {\n                        costs[n] = newCost;\n                        parents[n] = node;\n                    }\n                }\n            }\n            const el = document.getElementById(node);\n            if (el && el.className !== 'start-node' && el.className !== 'end-node' && !walls.includes(node)) el.className = 'visited';\n            if (node === graph.endNode) {\n                clearInterval(interval);\n                resolve()\n            }\n            processed.push(node);\n            node = lowestCostNode(costs, processed);\n            if (!node) clearInterval(interval);\n        }, 10)\n    });\n    \n    await myPromise\n\n    let optimalPath = [graph.endNode];\n    let parent = parents[graph.endNode];\n\n    while (parent) {\n        optimalPath.push(parent);\n        parent = parents[parent];\n    }\n      \n    optimalPath.reverse();\n\n    const results = {\n    distance: costs[graph.endNode],\n    path: optimalPath\n    };\n    completed = true;\n    return results;\n}\n","import React from 'react';\nimport { dijkstra,boxes, walls } from '../../algorithms/dijkstras';\n\nexport const Nav = () => {\n    const handleClick = async () => {\n        for( let box of boxes) {\n            const el = document.getElementById(box);\n            if (el.className === 'visited' || el.className === 'path') el.className = 'unvisited'\n        }\n        let result = await dijkstra();\n        result.path.shift()\n        result.path.pop()\n        let i = 0, length = result.path.length;\n        const interval = setInterval(() => {\n            document.getElementById(result.path[i]).className = 'path'\n            i++;\n            if (i === length) clearInterval(interval);\n        },1)\n    }\n    const handleClear = () => {\n        for( let box of boxes) {\n            const el = document.getElementById(box);\n            if (el.className === 'visited' || el.className === 'path' || el.className === 'wall') el.className = 'unvisited'\n            if (walls.includes(box)) walls.splice(walls.indexOf(box),1);\n        }\n    }\n    return (\n        <div className='nav'>\n            <div className='nav-title'>\n                <h1>Path Visualizer</h1>\n            </div>\n            <div className='algo-button'>\n                <button onClick={handleClick}>Run Algorithm</button>\n            </div>\n            <div className='clear-button'>\n                <button onClick={handleClear}>Clear Board</button>\n            </div>\n        </div>\n    )\n}","import { createSlice } from '@reduxjs/toolkit';\n\nconst gridSlice = createSlice({\n    name: 'grid',\n    initialState: {\n        grid: {\n            rows: null,\n            cols: null\n        }\n    },\n    reducers: {\n        setGrid(state,action) {\n            return {\n                grid: action.payload\n            }\n        }\n    }\n})\n\n//Actions\n/////////////////////////////////////////////////////////////\nexport const { setGrid } = gridSlice.actions;\n\n//Reducer\n/////////////////////////////////////////////////////////////\nexport default gridSlice.reducer;\n\n//Selectors\n/////////////////////////////////////////////////////////////\nexport const selectGrid = (state) => state.grid;","import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { selectGrid } from './gridSlice'\nimport { graph, buildGraph, walls } from '../../algorithms/dijkstras';\n\nexport const Gridrow = ({ mouseDown, setMouseDown, node, setNode, currentRow }) => {\n    const { grid } = useSelector(selectGrid);\n\n    const handleMouseDown = (e) => {\n        e.preventDefault()\n        /* If the clicked box is a start or end node\n        Set previous node to current node\n        Set currentlyMoving to true and \n        Set the type of node to be the start or end node */\n        if (e.target.className.includes('node')) setNode({previous: e.target, currentlyMoving: true, type: e.target.className})\n        setMouseDown(true);\n        addRemoveWalls(e.target);\n    }\n    const handleMouseUp = ({ target }) => {\n        //Set the start and end node in the graph\n        if (target.className === 'start-node') graph.startNode = target.id;\n        else if (target.className === 'end-node') graph.endNode = target.id;\n        //Start or end node is no longer moving \n        setNode({...node, currentlyMoving: false});\n        setMouseDown(false);\n    }\n    const handleMouseLeave = ({ target }) => {\n        /* If the mouse leaves a box that is a wall and\n        The start or end node is currently being moved,\n        Set the previously visited box to a wall */\n        if (walls.includes(target.id) && node.currentlyMoving) target.className = 'wall';\n        if (node.type === 'start-node' && target.id === graph.endNode) target.className = 'end-node';\n        if (node.type === 'end-node' && target.id === graph.startNode) target.className = 'start-node';\n    }\n    const handleMouseEnter = ({ target }) => {\n        //If the start or end node is currently being moved\n        if (node.currentlyMoving) {\n            //Set the newly entered box to the start or end node\n            target.className = node.type;\n            //If the previously visited box is not a wall, set it to unvisited\n            if (node.previous.className !== 'wall') node.previous.className = 'unvisited';\n            //Set the previous node to be the current box\n            setNode({...node, previous: target});\n        } else if (mouseDown) addRemoveWalls(target);\n    }\n    const addRemoveWalls = (target) => {\n        switch (target.className) {\n            case 'unvisited':\n                //Add newly entered box to walls\n                walls.push(target.id);\n                //Change current box to a wall\n                target.className = 'wall';\n                break;\n            case 'wall':\n                //Remove current box from walls\n                walls.splice(walls.indexOf(target.id),1);\n                //Change current box to unvisited\n                target.className = 'unvisited';\n                break;\n            default:\n                break;\n        }\n    }\n    const getRows = () => {\n        return [...Array(grid.cols).keys()].map(col => {\n            let cName;\n            (graph.startNode === `${currentRow}-${col}`) ? cName = 'start-node' :\n            (graph.endNode === `${currentRow}-${col}`) ? cName = 'end-node' :\n            (walls.includes(`${currentRow}-${col}`)) ? cName = 'wall' : cName = 'unvisited';\n            buildGraph(`${currentRow}-${col}`,cName);\n            return <td key={col} \n                        id={`${currentRow}-${col}`} \n                        className={cName} \n                        onMouseEnter={handleMouseEnter} \n                        onMouseDown={handleMouseDown} \n                        onMouseUp={handleMouseUp} \n                        onMouseLeave={handleMouseLeave}></td>\n        })\n    }\n    return getRows()\n}","import React, { useState, useEffect } from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { setGrid, selectGrid } from './gridSlice'\nimport { Gridrow } from './Gridrow';\nimport { graph} from '../../algorithms/dijkstras';\n\nexport const Grid = () => {\n    const { grid } = useSelector(selectGrid);\n    const dispatch = useDispatch();\n    const [mouseDown, setMouseDown] = useState(false);\n    const [node, setNode] = useState({target: null, bool: false});\n\n    useEffect(() => {\n        let rows = Math.floor((window.innerHeight - 25) / 28);\n        let cols = Math.floor(window.innerWidth / 25)-6;\n        graph.rows = rows;\n        graph.cols = cols;\n        const vertMiddle = Math.floor(rows / 2);\n        const horzFirstThird = Math.floor(cols / 6);\n        const horzLastThird = cols - Math.floor(cols / 6);\n        graph.startNode = `${vertMiddle}-${horzFirstThird}`;\n        graph.endNode = `${vertMiddle}-${horzLastThird}`;\n        dispatch(setGrid({rows,cols}))\n    },[dispatch])\n    const handleMouseLeave = (e) => {\n        setNode({...node, currentlyMoving: false, bool: false});\n        setMouseDown(false);\n    }\n    const getRows = () => {\n        return [...Array(grid.rows).keys()].map(row => <tr key={row} id={`row-${row}`}>\n            <Gridrow key={row} \n                    currentRow={row}  \n                    mouseDown={mouseDown} \n                    setMouseDown={setMouseDown}\n                    node={node} \n                    setNode={setNode} /></tr>)\n    }\n    return (\n        <div className='grid-container' onMouseLeave={handleMouseLeave}>\n        <div className='grid'>\n            <table className='grid-table'>\n                <tbody>\n                    {getRows()}\n                </tbody>\n            </table>\n        </div>\n        </div>\n    )\n}","import React from 'react';\nimport { Nav } from '../components/nav/Nav'\nimport { Grid } from '../components/grid/Grid'\n\nexport const App = () => {\n    return (\n        <main className='App'>\n            <Nav />\n            <Grid />\n        </main>\n    )\n}","import { configureStore }  from '@reduxjs/toolkit';\nimport gridReducer from '../components/grid/gridSlice';\n\n\nexport const store =  configureStore({\n    reducer: {\n        grid: gridReducer\n    }\n})","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\n\nimport { App } from './app/App';\nimport { store } from './app/store'\n\n  ReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n  )"],"sourceRoot":""}